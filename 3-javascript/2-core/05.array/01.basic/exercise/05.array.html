<html>

<body>
  <script>
    // 입력값은 arr = [1, -2, 3, 4, -9, 6] 같이 숫자로만 구성된 배열이라고 가정해봅시다.
    // 우리가 해야 할 일은 인접한 요소의 총합이 최대인 arr의 부분 배열을 찾는 것입니다.
    // 부분 배열 요소들의 합을 리턴하는 함수 getMaxSubSum(arr)를 작성해 봅시다.

    // getMaxSubSum([-1, 2, 3, -9]) == 5(강조 표시된 요소들의 합)
    // getMaxSubSum([2, -1, 2, 3, -9]) == 6
    // getMaxSubSum([-1, 2, 3, -9, 11]) == 11
    // getMaxSubSum([-2, -1, 1, 2]) == 3
    // getMaxSubSum([100, -9, 2, -3, 5]) == 100
    // getMaxSubSum([1, 2, 3]) == 6(모든 요소)

    // 요소 전체가 음수라면 아무런 요소도 선택하지 않아야 최댓값이 됩니다
    // (부분 배열은 빈 배열). 그리고 합은 0이 됩니다.
    // getMaxSubSum([-1, -2, -3]) = 0;

    function getMaxSubSum(arr) {
      let max = 0;
      let temp = 0; // 부분근접 한산

      // 처음부터 끝까지 요소를 탐색
      // length: 6, 0~6

      // 예) [1, -2, 3, 4, -9. 6]
      for (let i = 0; i < arr.length; i++) {
        for (let j = i; j < arr.length; j++) {
          // 현재 요소와 이전 합산을 더함
          temp += arr[j];
          //  1 : 1, -1, 2, 6, -3, 3
          // -2 : -2, 1, 5, -4, 2
          //  3 : 3, 7, -2, 4 이런식

          // 연산 횟수(=반복문의 횟수)
          // 1 + ~ + n(length)
          // (n+1) *(n/2)
          // n**2 +

          if (temp > max) {
            max = temp;
          }
        }
        temp = 0; // 한번 다돌아서 0

      }

      return max;
    }

    let test = [
      [1, -2, 3, 4, -9, 6],
      [2, -1, 2, 3, -9],
      [-1, 2, 3, -9, 11],
      [-2, -1, 1, 2],
      [100, -9, 2, -3, 5],
      [1, 2, 3],
    ]

    for (let elm of test) {
      console.log(getMaxSubSum(elm));
    }

    // O(n^2)
  </script>
</body>

</html>